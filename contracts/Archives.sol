pragma solidity ^0.4.24;

import "./Whitelist.sol";
//Top level contract inherits the implementation of "user permissions"
contract Archives is Whitelist {

    //Struct data type containg basic artwork proprieties to be stored in contracts
    struct Artwork {
        uint id; //unique identifier
        address author; //identifies who inserts the Artwork
        string name;
        string descriptionHash; //short Artwork descriptionHash (may not be necessary, depends on the final encoding tech)
        string mainPreviewHash; //stores the hash generated by IPFS to retrieve all the information about the Artwork
        bool validation; //indicates if the Artwork is approved by given quorum of artworkCheckers
        uint votesNum; //number of votes casted on this particular artwork
    }
    //Struct to store an array of votes made by artworkCheckers
    struct VoteRegister {
        uint[] myVotes; // this array stores alle the ids that receive a vote from a certain address, referenced in mapping 
    }

    //STATE VARIABLES
    //Maps a reference by "id" to the Artwork struct
    mapping (uint => Artwork) public artworks; //automatically sets a getter
    //Maps a reference by "address" to the VoteRegister struct
    mapping (address => VoteRegister) validators;
    //stores the total number of works submitted
    uint artworkCounter;

    //EVENTS
    //An Artwork has been published log
    event LogSendArtw(
        uint indexed _id,
        address indexed _author,
        string _name,
        string _descriptionHash,
        string _data,
        bool validation
    );
    //An Artwork has been validated log
    event ValidateArtw(
        uint indexed _id,
        address indexed _author
    );

    event artworkModify(
        uint indexed _id,
        address indexed _author
    );

    //Modifiers
    //Checks if the artwork has not yet been validate, if it has there is no point on voting that id
    modifier checkValidation(uint _id) {
        require(
            artworks[_id].validation == false,
            "Impossibile to validate an artwork which is already valid"
        ); //check if the artwork is not already "valid"
        require(
            artworkCounter >= _id,
            "Impossibile to approve (validate) non existent artwork id"
        ); //doesn't allow to vote on non existent Artwork ids, also tested for negatives
        _;
    }

    //publish an artwork (main form)
    function publishArtwork(string _name, string _descriptionHash, string _mainPreviewHash) public {
        //new artwork
        artworkCounter++;
        artworks[artworkCounter] = Artwork(
            artworkCounter,
            msg.sender,
            _name,
            _descriptionHash,
            _mainPreviewHash,
            false,
            0
        );

        emit LogSendArtw(artworkCounter, msg.sender, _name, _descriptionHash, _mainPreviewHash, false);
    }

    //adding examples articles when deploying contract, just an example 
    //can be extended to insert inital dataset
    constructor() public  {
        addArtwork(1, 0x9Fb867de1eD00990FCFFefC7925846068561ef3C, "Opera d'arte minore approvata", "QmRDKiVKaEFxcEa5z9haS1fEhQbQriqYgNnAsHmgxM2de6", "QmVFCTESBiwPExSBYkA5EKLQ1MHWKYG2UuHSxZAWoQHLhE", true, 2);
        addArtwork(2, 0x9Fb867de1eD00990FCFFefC7925846068561ef3C, "Opera d'arte scultura", "QmRDKiVKaEFxcEa5z9haS1fEhQbQriqYgNnAsHmgxM2de6", "QmVFCTESBiwPExSBYkA5EKLQ1MHWKYG2UuHSxZAWoQHLhE", false, 0);
    }
    //manual artwork adding for constructor useful for test, should be removed in production!
    function addArtwork(uint _id, address _author, string _name, string _descriptionHash, string _mainPreviewHash, bool _validation, uint _votesNum) internal {
        artworkCounter++;
        artworks[artworkCounter] = Artwork (
            _id,
            _author,
            _name,
            _descriptionHash,
            _mainPreviewHash,
            _validation,
            _votesNum
        );
    }

    //fetch the number of artworks in the contract
    function getNumberOfArtworks() public view returns(uint) {
        return artworkCounter;
    }
    //display all artworks stored in blockchain
    function getArtworks() public view returns(uint[]) {
        //prepare output array, it cannot contain more artworks than we have in the contract
        uint[] memory artwIds = new uint[](artworkCounter);
        uint numberOfArtw = 0;
        //iterate over artworks
        for(uint i = 1; i <= artworkCounter; i++) {
            artwIds[numberOfArtw] = artworks[i].id;
            numberOfArtw++;
        }
        //copy the artworks Ids array into smaller displayArt array
        uint[] memory displayArt = new uint[](numberOfArtw);
        for(uint j = 0; j < numberOfArtw; j++) {
            displayArt[j] = artwIds[j];
        }
        return displayArt;
    }
    //artwork checkers can vote on artwork propriety "votesNum" and store their votes in storage
    function approveArtwork(uint _id) public onlyIfWhitelisted(msg.sender) checkValidation(_id) {
        VoteRegister storage validator = validators[msg.sender];
        for (uint i = 0; i < validators[msg.sender].myVotes.length;i++){
            require(
                !(validators[msg.sender].myVotes[i] == _id),
                "Error, Msg.sender already voted this artwork id in the past"
            );
        }
        validator.myVotes.push(_id);
        artworks[_id].votesNum++;
        completeValidation(_id);
    }
    //checks if the "quorum" number has been met, static example of "2", can be e.g 1/3 of total artworkCheckers
    function completeValidation(uint _id) internal {
        if (artworks[_id].votesNum >= 2 ) {
            artworks[_id].validation = true;
            emit ValidateArtw(_id, msg.sender);
        }
    }
    
    function modifyArtworkDescription (uint _id, string _newDescriptionHash) public {
        require(
            msg.sender == artworks[_id].author,
            "Msg.sender address doesn't correspond to artwork author address resulting in unauthorized attempt to modify artwork description"
        );
        artworks[_id].descriptionHash = _newDescriptionHash;
        artworks[_id].votesNum = 0; 
        artworks[_id].validation = false;
        emit artworkModify(_id, msg.sender);
    }

    //returns votes made by given artworkChecker and shows the length of array containg all artworkCheckers
    //for debug purposes
    /*function quorum() view public returns (uint[], uint) {
        return (
            validators[msg.sender].myVotes,
            artworkCheckersAccount.length
            );
    }*/
}